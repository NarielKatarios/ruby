Всем прочитать:
1 - ПЕРЕМЕННЫЕ
- https://ru.wikibooks.org/wiki/Ruby/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5
2 - ТИПЫ ДАННЫХ
- https://ru.wikibooks.org/wiki/Ruby/%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B5_%D1%82%D0%B8%D0%BF%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85
3 - ЧИСЛА
- https://ru.wikibooks.org/wiki/Ruby/%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5_%D0%BE_%D1%87%D0%B8%D1%81%D0%BB%D0%B0%D1%85

когда закрепите предыдущие три статьи
4 - МАССИВЫ
- https://ru.wikibooks.org/wiki/Ruby/%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5_%D0%BE_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D1%85
5 - ХЭШИ
- https://ru.wikibooks.org/wiki/Ruby/%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5_%D0%BE%D0%B1_%D0%B0%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D1%85_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B0%D1%85
6 - СТРОКИ
- https://ru.wikibooks.org/wiki/Ruby/%D0%9F%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%B5%D0%B5_%D0%BE_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D1%85

----------------------------------------------


!!!!!!!!!!!!!!!терминал
narielkatarios@NarielKatarios-Lenovo-V110-15ISK:~$
ls - показывает все папки
mkdir ruby - возвращает выше в папку?
fish - программа для помощи
./RubyMine/bin/rubymine.sh  - запуск рубимайн из терминала
sudo apt-get update - после установки линукса - обновление
sudo apt get mc - слетела руби, не работает ирб
️~ - тильда означает дрмашнюю папку
cd = change directory - войти в папку из домашней папки
-----------------------------------------------
установи bundler mc fish
sudo apt-get install bundler mc fish
 ---------------------------------------------
 github.com

ЧТОБЫ ЗАПУШИТЬ ЗАДАНИЯ В ГИТХАБ!
выполни в терминале в своей папке
cd ruby
git add .
    git commit -m 'lesson 8'
git push
(или git push origin master если не получится)
ПЕРВОЕ ПОЛУЧИЛОСЬ
-------------------------------------------------
установка РУБОКОПА
gem install rubocop
проверить рубокопом все файлы на ошибки
rubocop ./
автоматическое исправление ошибок
rubocop -a ./
--------------------------------------------------
как файл в терминале открыть
прям из корневой папки
ruby ruby/04/main.rb
или
cd ruby
ruby 04/main.rb
командная строка предназначена для работы с файлами
а интерпретатор руби - только с командами и аргументами
тоесть
load - это команда
а имя файла в кавычках - это аргумент строка
если написать без кавычек - то интерпретатор подумает что это команда или переменнная
---------------------------------------------------------------
!!!!!!!!!!!!!!!!БРАУЗЕР!
http://rextester.com/l/ruby - руби в онлайне
rubular.com - справочник шаблонов- регулярных выражений

--------------------------------------------------------






!!!!!!!!!!!!!!!Рубимайн
shift+f6+fn- переименовать файл
edit undo - отмена последнего действия
control+r- замена текста
------------------------------------------------
МЕТОД PUTS - вывести на экран строку
puts - просто выводит на экран всё, что следует за ним
puts     5 * (12-8) + -15
возврат -29802
puts 'Привет, мир!'
возврат Привет, мир!
puts 'Я люблю ' + 'яблочный пирог.'
возврат Я люблю яблочный пирог.
puts 'миг ' * 4
возврат миг миг миг миг
----------------------------------------------
МЕТОД GETS - получить строку
МЕТОД CHOMP - убирает все энтеры в конце строки
name = gets.chomp
------------------------------------------
МЕТОД REVERSE - выдаёт значение строки, перевёрнутое задом наперёд:
var1 = 'барк'
puts var1.reverse
краб
-----------------------------
МЕТОД LENGTH
name.length.to_s - '22'
-------------------------------------
МЕТОД UPCASE изменяет каждую строчную букву на заглавную
метод DOWNCASE изменяет каждую заглавную букву на строчную.
МЕТОД SWAPCASE переключает регистр каждой буквы в строке
МЕТОД CAPITALIZE как downcase, только он переводит первую букву в заглавную (если
это буква).
letters = 'aAbBcCdDeE'
puts letters.capitalize
Aabbccddee
МЕТОД CENTER добавляет пробелы в начале и конце, чтобы центрировать строку
lineWidth = 50
puts( 'Так никто не визжал,'.center(lineWidth))
           так никто не визжал,
                        ljust и rjust, названия которых
МЕТОДЫ LJUST и RJUST (выровнять влево) и (выровнять вправо)
5**2 - 5 в степени 2 - 25
5**0,5 - квадратный корень из 5 - 2.23606797749979
5%2 - выводит остаток после деления - 1
(5-2).abs и ((2-5).abs) - абсолютное значение - 3
МЕТОД RAND - рандомное дробное число от 0 до 1
rand(5) - рандомное целое от 0 до 5 (5 не входит)
МЕТОД SRAND зерно случайной последовательности, чтобы повторить такие же рандомные числа
МЕТОДЫ СРАВНЕНИЯ
puts 5 >= 5 - true
1 > 2 - false
= - присваивание - переменная равна
== - эти два объекта равны??
!= - эти два объекта не равны??
puts 'cat' < 'dog' - тру - по алфавиту (прописная имеет значение)











---------------------
  2.to_s #возвращает строковую версию объекта '2'
'2'.to_i #возвращает целочисленную версию значения объекта 2
  2.to_f #возвращает плавающую версию 2.0
--------------------------
МЕТОД ВЕТВЛЕНИЯ IF ELSE и END
 МЕТОД ЦИКЛОВ WHILE
 control+c - выход из бесконечного цикла
 МЕТОД ЛОГИЧЕСКИХ ОПЕРАЦИЙ OR AND NOT
 ----------------------------
 МОДУЛЬ MATH
(Math::PI) # - число Пи - 3.14159265358979
((1 + Math.sqrt(5))/2) - 1.61803398874989
-------------------------------------------
МАССИВЫ m = [1, 2, 3, 4]
m[0] - 1 - первый объект в массиве
МЕТОД EACH - делать что-то с каждым объектом массива
это метод массива - итератор (метод как цикл) всегда с do end
 m.each do |index| puts index
 end
 МЕТОД TIMES - итератор целого числа
 3.times do
   puts 'hello'
 end
 3.times do |i| puts i end
 3.times {|i| puts i}
МЕТОД JOIN - разделяет строковые объекты массива чем-нибудь
 m.to_s - 1234
 m.join('! ') - 1! 2! 3! 4
МЕТОД LAST  - показывает последний объект массива
 m.last - 4 - последний
 МЕТОД LENGTH - длина массива
 m.length - 4  - количество
 МЕТОД POP  - удаляет последний и показывает его
 m.pop - 4 - удаляет последний, показывает, какой
 МЕТОД SORT - сортирует объекты массива






------------------------------------------------------------
БЛОКИ
 3.times {|i| puts i}
0
 1
 2
def m(i)
  puts i
end

 for i in 1..3
   m(i)
 end
 1
 2
 3

 h = {a: 1, b: 2, c: 3}
 h.each do |value|
   puts value.inspect
 end
a
 b
[:c=>3]
 h.each do |key, value|
puts "#{key} => #{value}"
a
b
c => 3
[1,2,3,4].each { |i| puts i * 10}
10
20
30
40

line_num = 0
file.open('blocks.rb').each do |line|
  puts "#{line_num += 1}: #{line}"
end
1: - все строки файла
2:

сохранить блок в переменную - создание объекта класса Прок
a = Proc.new {|x| x = x * 10; puts x}
b = proc {|x| x = x * 10; puts x}
c = lambda {|x| x = x * 10; puts x} лямда контроллирует количество аргументов
вызов блока
a.call(100)
1000

x = "hello"
block = Proc.new {puts x}
block.call
hello
def m(block)
  x = "goodbye"
  puts "X from method: #{x}"
  block.call
end
m(block)
X from method: goodbye
hello

вызвать переданный блок МЕТОД YIELD
def m
  puts "Before block"
yield
  puts "After block"
end
m {puts "Inside block"}
Before block
Inside block
After block

ДАННЫЕ В БЛОК - неименованый
def caps(str)
  str.capitalize! #!изменяется строка с заглавной буквы
  yield(str)
end
caps('abc')  {|str| puts str[0]}
A
caps('abc')  {|str| puts str}
Abc

ПЕРЕДАЧА БЛОКА КАК ИМЕНОВАНОГО АРГУМЕНТА
def caps(str, block)
  str.capitalize!
  block.call(str)
end
block = lambda {|x| puts x}
caps 'abc', block
Abc

ЕЩЕ ОДИН СПОСОБ ЗАДАНИЯ АРГУМЕНТА БЛОКА КАК АРГУМЕНТА МЕТОДА
def caps(str, &block) - #последний аргумент c & должен быть передан в блок
str.capitalize!
block.call(str)
end
caps('abc') {|x| puts x}
Abc

def caps(str, &block)
str.capitalize!
block.call(str).
                   yield(str)
end
caps('abc') {|x| puts x}
Abc
Abc

ПЕРЕДАН БЛОК ИЛИ НЕТ
def m(str, &block)
if block_given?
  yield(str)
else
  puts str
  end
m('abc')
m('abc') {|x| x; capitalize!; puts x}
Abc
-------------------------
ИДИОМЫ
i = 0
0
i = i + 1
1
i += 1 #идиома
2

i = 0
0
x, y = 1, 2
[1, 2]
x
1
y
2

x, y = y, x #идиома

array = [1, 2, 3]
a = array[0]
1
b = array[1]
2
a, b, c = array #идиома - множественное присваивание
||= # оператор или присвоить, если в значении переменной нет
#запись дефолтного значения
class Foo
  def bar(key)
    h = {a: 1, b: 2}
    value = hash(key)
    value ||= 0 #value = 0 unless value
    # ... используем value
    #
  end

  def long_method
    sleep(3)
  end

  def memoization
    @m ||= long_method # мемоизация memory find
  end
 end
  foo = Foo.new
  foo.bar(:a)
  1
  foo.bar(:c)
  0
  foo.long_method
  3
  foo.memoization
  3

  class User
    attr_accesor :name

    def has_name? # метод? возвращает тру фолс
      !!name # двойное отрицание
      # name.nil? ? false : true - возвращает труфолс
      # name - возвращает имя либо нил
      # !name -
    end

    def has_not_name?
      !has_name?
    end

    def name=(value)
      @name = value.capitalize
    end
  end

name = "qwerty"
"qwerty"
!name
false
name = nil
!name
true
  user = User.new
  user.has_name?
  false
  user.name = 'dmitry'
  'Dmitry'
  user.has_name?
  true


  #синтаксис # записи массивов + с помощью создания блоков
fruits = %w(apple orange grape)
  ['apple', 'orange', 'grape']
  fruits.map { |f| f.upcase }
  ['APPLE', 'ORANGE', 'GRAPE']
  fruits.map(&:upcase) #возвращает новый массив
  ['APPLE', 'ORANGE', 'GRAPE']
  fruits.each(&:upcase) #возвращает оригинальный массив
  ['apple', 'orange', 'grape']

#использование хэша вместо оператора кэйс?
class Color
  COLORS = { red: "#f00",green: "#0f0", blue: "#00f", white: "fff"}
end
  def code(name)
    @code = COLORS[name] || "#000"
     # @code = case name
    #           when :red
    #             "#f00"
    #           when :green
    #             "#0f0"
    #           when :blue
    #             "#00f"
    #           when :white
    #             "fff"
    #           else
    #             "#000"
    #           end
  end

  alias_method :by_name, :code # элиасы методов - синонимы
end
# метод должен быть менее 10 строк
color = Color.new
  color.code(:nothing)
  "#000"

   def m(hash)
   end
m({a: 1, b: 2})
   nil
   m(a: 1, b: 2)
def m(arg1, hash)
end
   nil
   m(3, a: 1, b: 2)

class Train
  attr_accessors :type, :model, :number, :number_of_wagons

  def initialize(number, *args) #массив
#    def initialize(number, type = "Unknown", model = "Unknown", number_of_wagons = 0 )

    @number = number
      @type = args[0] || "Unknown"
      @model = args[1] || "Unknown"
      @number_of_wagons = args[2] || 0
    # @type = type
    # @model = model
    # @number_of_wagons = number_of_wagons
  end

  t = Train.new('123')
  t = Train.new('123', 'cargo')

  def initialize(number, options = {}) #хэш

    @number = number
    @type = options[:type] || "Unknown"
    @model = options[:model] || "Unknown"
    @number_of_wagons = options[:number_of_wagons] || 0
# @type = type
# @model = model
# @number_of_wagons = number_of_wagons
  end

  t = Train.new('123')
  t = Train.new('123', type: 'cargo')
  t = Train.new('123', number_of_wagons: 5, type: 'cargo')

  # в руби все классы являются открытыми

  class String
    def self.random(length)
      rand(36**length).to_s(36)
    end

      def my_method
        self.capitalize
      end

    def <<(value)
      "#{self} #{value}"
    end
  end

  "str".class
  "str".my_method
  "str"
  "str" << "abc"
"str abc"
  String.random(3)
 "ol6"

  #синглтон метод - возможность добавить некоторый метод к одному объекту

  class Foo
  end
  foo = Foo.new
  foo.m

  class << foo
    def m
      puts "Only for one object"
    end
  end

  foo.m
Only for one object
---------------------------------------------------------------
МЕТАПРОГРАММИРОВАНИЕ
        1.class
Fixnum
        1.public_methods
# все методы с целым числом списком
        x=0
0
        puts "#{x +=}"
1
        x
1
        puts "#{x +=}"
2
        eval('x += 1 ')
3
        x
3
        eval(' def m(a)
        a * 10
        end
        puts m(5)')
50





--------
line_num = 0
input = ""

loop do
    print "#{line_num += 1}?: "
    line = gets
    break if line.strip == 'exit'   # стрип удаляет пустые пробелы в начале и конце строки

    if line.strip == ''
        puts "Evaluating..."
        puts eval(input)
        input = ""
    else
        input += line
end
--------
        2+3
5
        puts "Hello world"
Hello world
        def m; puts "m"; end

        m
m
        a = 2
2
        a + 3
цикл чтение исполнение печать
---------
    def m(a)
        a * 10
    end
Evaluation...

Evaluation...
60
    [1, 2, 3, 4].each do |i|
        puts i * 10
    end

Evaluation...

10
20
30
40
1
2
3
4
    a = 0
    a *= 10
    puts a
Evaluation...
0
------------
    obj = Object.new
    obj.instance_eval("def m
    puts 'hello'
    end")

    obj.m
hello
----------------
class Foo
    def initialize
        @bar = "instance var"
    end

    private

    def private_method
        puts "I'm private method"
    end
end
------
    foo = Foo.new
    foo.instance_eval('@bar')
"instance var"
    foo.instance_eval('private_method')
I'm private method
    foo.instance_eval do
        def m
        puts "public method"
        puts "instance var: #{@bar}"
        private_method
        end
    end
    foo.m
public method
instance var: instance var
I'm private method
----------
    module X
        end

    class Y
        @@y = 12
        include X
    end
Y
    Y.class_eval('@@y')
12
    Y.class_eval do
        def m
        puts 'hello'
        end
    end

     y = Y.new
     y.m
hello
    X.module_eval do
        def module_method
        puts 'module method'
        end
    end

     y.module_method
module_method

    class Y
        class_eval do
            def another_method
            puts '123'
            end
        end
    end

    y.another method
123

    Y.class_variables # все переменные класса
[:@@y]
    Y.class_variable_get :@@y   #вызвать значение переменной КЛАССА
12
    Y.class_variable_set :@@y, 45   #установить значение переменной
45
    Y.class_variable_get :@@y
45
    Y.class_variable_set :@@x, 34   #ввести новую переменную
34
    Y.class_variables
[:@@y, :@@x]

    y = Y.new
    y.instance_variable_get :@x     #инстанс переменная
    y.instance_variable_set :@x, 56
56
    y.instance_variable_get :@x
56
    y.instance_variables
[:@x]
    y2 = Y.new
    y2.instance_variable_get :@x
nil
    y2.instance_variables
------
МЕТОД ДИНАМИЧЕСКОГО ОБЪЯВЛЕНИЯ МЕТОДА
приватный метод, который создает другие методы

    class Y
        define_method(:my_method) do
            puts "my method"
        end
    end

    y = Y.new
    y.my_method)
my method
    Y.const_set :MY, 5
5
    Y.const_Get :MY
5
 ----------------
module MyAttrAccessor
    def my_attr_accessor(*name) #массив элементов
        name.each do |name|
            var_name = "@#{name}".to_sym
            define_method(name) { instance_variable_get(var_name) }
            define_method("#{name}=".to_sym) { |value| instance_variable_set(var_name, value)}
        end
    end
end

class Test
    extend MyAttrAccessor

    my_attr_accessor :my_attr, :a, :b, :c
end
-------------------
    test v= Test.new
    test.instance_variables
[]
    test.my_attr
nil
    test.my_attr = 5
5
    test.my_attr
5
    test.instance_variables
[:@my_attr]
    test
----------------------
puts "Enter string"
str = gets.chomp
puts "Enter method"
method = gets.chomp.to_sym #метод преобразовывается в символ!!
puts str.send(method) #выводим значение
---------
Enter string
qwerty
Enter method
lenght
6

Enter string
abc
Enter method
raise
unhandled exception
------
    "str".send(:raise, ArgumentError)
ArgumentError:ArgumentError
    2.send(:+, 5)
7

метод удаления метода
    "abc".reverse
"cba"
    class String
        remove_method :reverse
    end
String
    "abc".reverse
undefined method
----------------
class X
    def m
        puts "hello"
    end
    def method_missing(name, *args)
        puts "Called method #{name} with arguments #{args}"
        end
    end
nil
    x = X.new
    x.m
hello
    x.abc
Called method abc with arguments []
    x.my_method[1, 2, 3]

    class X
        def method_missing(name, *args)
            self.class.send(:define_method, name.to_sym, lambda { |*args| puts args.inspect })
        end
    end

    x = X.new
    x.public_methods
    x.abc 1,2,3
    x.xyz
    x.public_methods
    x.abc
[1, 2, 3]

















  -------------------------------------------------------------
ВОПРОСЫ!!!!!!!!!!!!!
про неработающий мик: надо гуглить именно эту модель ноутбука


