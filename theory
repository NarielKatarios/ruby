!!!!!!!!!!!!!!!терминал
narielkatarios@NarielKatarios-Lenovo-V110-15ISK:~$
ls - показывает все папки
mkdir ruby - возвращает выше в папку?
fish - программа для помощи
./RubyMine/bin/rubymine.sh  - запуск рубимайн из терминала
sudo apt-get update - после установки линукса - обновление
sudo apt get mc - слетела руби, не работает ирб
️~ - тильда означает дрмашнюю папку
cd = change directory - войти в папку из домашней папки
-----------------------------------------------
установи bundler mc fish
sudo apt-get install bundler mc fish
 ---------------------------------------------
 github.com

ЧТОБЫ ЗАПУШИТЬ ЗАДАНИЯ В ГИТХАБ!
выполни в терминале в своей папке
cd ruby
git add .
    git commit -m 'задание 6'
git push
(или git push origin master если не получится)
ПЕРВОЕ ПОЛУЧИЛОСЬ
-------------------------------------------------
установка РУБОКОПА
gem install rubocop
проверить рубокопом все файлы на ошибки
rubocop ./
автоматическое исправление ошибок
rubocop -a ./
--------------------------------------------------
как файл в терминале открыть
прям из корневой папки
ruby ruby/04/main.rb
или
cd ruby
ruby 04/main.rb
командная строка предназначена для работы с файлами
а интерпретатор руби - только с командами и аргументами
тоесть
load - это команда
а имя файла в кавычках - это аргумент строка
если написать без кавычек - то интерпретатор подумает что это команда или переменнная
---------------------------------------------------------------
!!!!!!!!!!!!!!!!БРАУЗЕР!
http://rextester.com/l/ruby - руби в онлайне
rubular.com - справочник шаблонов- регулярных выражений

--------------------------------------------------------






!!!!!!!!!!!!!!!Рубимайн
shift+f6+fn- переименовать файл
edit undo - отмена последнего действия
control+r- замена текста
------------------------------------------------
МЕТОД PUTS - вывести на экран строку
puts - просто выводит на экран всё, что следует за ним
puts     5 * (12-8) + -15
возврат -29802
puts 'Привет, мир!'
возврат Привет, мир!
puts 'Я люблю ' + 'яблочный пирог.'
возврат Я люблю яблочный пирог.
puts 'миг ' * 4
возврат миг миг миг миг
----------------------------------------------
МЕТОД GETS - получить строку
МЕТОД CHOMP - убирает все энтеры в конце строки
name = gets.chomp
------------------------------------------
МЕТОД REVERSE - выдаёт значение строки, перевёрнутое задом наперёд:
var1 = 'барк'
puts var1.reverse
краб
-----------------------------
МЕТОД LENGTH
name.length.to_s - '22'
-------------------------------------
МЕТОД UPCASE изменяет каждую строчную букву на заглавную
метод DOWNCASE изменяет каждую заглавную букву на строчную.
МЕТОД SWAPCASE переключает регистр каждой буквы в строке
МЕТОД CAPITALIZE как downcase, только он переводит первую букву в заглавную (если
это буква).
letters = 'aAbBcCdDeE'
puts letters.capitalize
Aabbccddee
МЕТОД CENTER добавляет пробелы в начале и конце, чтобы центрировать строку
lineWidth = 50
puts( 'Так никто не визжал,'.center(lineWidth))
           так никто не визжал,
                        ljust и rjust, названия которых
МЕТОДЫ LJUST и RJUST (выровнять влево) и (выровнять вправо)
5**2 - 5 в степени 2 - 25
5**0,5 - квадратный корень из 5 - 2.23606797749979
5%2 - выводит остаток после деления - 1
(5-2).abs и ((2-5).abs) - абсолютное значение - 3
МЕТОД RAND - рандомное дробное число от 0 до 1
rand(5) - рандомное целое от 0 до 5 (5 не входит)
МЕТОД SRAND зерно случайной последовательности, чтобы повторить такие же рандомные числа
МЕТОДЫ СРАВНЕНИЯ
puts 5 >= 5 - true
1 > 2 - false
= - присваивание - переменная равна
== - эти два объекта равны??
!= - эти два объекта не равны??
puts 'cat' < 'dog' - тру - по алфавиту (прописная имеет значение)











---------------------
  2.to_s #возвращает строковую версию объекта '2'
'2'.to_i #возвращает целочисленную версию значения объекта 2
  2.to_f #возвращает плавающую версию 2.0
--------------------------
МЕТОД ВЕТВЛЕНИЯ IF ELSE и END
 МЕТОД ЦИКЛОВ WHILE
 control+c - выход из бесконечного цикла
 МЕТОД ЛОГИЧЕСКИХ ОПЕРАЦИЙ OR AND NOT
 ----------------------------
 МОДУЛЬ MATH
(Math::PI) # - число Пи - 3.14159265358979
((1 + Math.sqrt(5))/2) - 1.61803398874989
-------------------------------------------
МАССИВЫ m = [1, 2, 3, 4]
m[0] - 1 - первый объект в массиве
МЕТОД EACH - делать что-то с каждым объектом массива
это метод массива - итератор (метод как цикл) всегда с do end
 m.each do |index| puts index
 end
 МЕТОД TIMES - итератор целого числа
 3.times do
   puts 'hello'
 end
 3.times do |i| puts i end
 3.times {|i| puts i}
МЕТОД JOIN - разделяет строковые объекты массива чем-нибудь
 m.to_s - 1234
 m.join('! ') - 1! 2! 3! 4
МЕТОД LAST  - показывает последний объект массива
 m.last - 4 - последний
 МЕТОД LENGTH - длина массива
 m.length - 4  - количество
 МЕТОД POP  - удаляет последний и показывает его
 m.pop - 4 - удаляет последний, показывает, какой
 МЕТОД SORT - сортирует объекты массива






------------------------------------------------------------
БЛОКИ
 3.times {|i| puts i}
0
 1
 2
def m(i)
  puts i
end

 for i in 1..3
   m(i)
 end
 1
 2
 3

 h = {a: 1, b: 2, c: 3}
 h.each do |value|
   puts value.inspect
 end
a
 b
[:c=>3]
 h.each do |key, value|
puts "#{key} => #{value}"
a
b
c => 3
[1,2,3,4].each { |i| puts i * 10}
10
20
30
40

line_num = 0
file.open('blocks.rb').each do |line|
  puts "#{line_num += 1}: #{line}"
end
1: - все строки файла
2:

сохранить блок в переменную - создание объекта класса Прок
a = Proc.new {|x| x = x * 10; puts x}
b = proc {|x| x = x * 10; puts x}
c = lambda {|x| x = x * 10; puts x} лямда контроллирует количество аргументов
вызов блока
a.call(100)
1000

x = "hello"
block = Proc.new {puts x}
block.call
hello
def m(block)
  x = "goodbye"
  puts "X from method: #{x}"
  block.call
end
m(block)
X from method: goodbye
hello

вызвать переданный блок МЕТОД YIELD
def m
  puts "Before block"
yield
  puts "After block"
end
m {puts "Inside block"}
Before block
Inside block
After block

ДАННЫЕ В БЛОК - неименованый
def caps(str)
  str.capitalize! #!изменяется строка с заглавной буквы
  yield(str)
end
caps('abc')  {|str| puts str[0]}
A
caps('abc')  {|str| puts str}
Abc

ПЕРЕДАЧА БЛОКА КАК ИМЕНОВАНОГО АРГУМЕНТА
def caps(str, block)
  str.capitalize!
  block.call(str)
end
block = lambda {|x| puts x}
caps 'abc', block
Abc

ЕЩЕ ОДИН СПОСОБ ЗАДАНИЯ АРГУМЕНТА БЛОКА КАК АРГУМЕНТА МЕТОДА
def caps(str, &block) - #последний аргумент c & должен быть передан в блок
str.capitalize!
block.call(str)
end
caps('abc') {|x| puts x}
Abc

def caps(str, &block)
str.capitalize!
block.call(str).
                   yield(str)
end
caps('abc') {|x| puts x}
Abc
Abc

ПЕРЕДАН БЛОК ИЛИ НЕТ
def m(str, &block)
if block_given?
  yield(str)
else
  puts str
  end
m('abc')
m('abc') {|x| x; capitalize!; puts x}
Abc
-------------------------
ИДИОМЫ
i = 0
0
i = i + 1
1
i += 1 #идиома
2

i = 0
0
x, y = 1, 2
[1, 2]
x
1
y
2

x, y = y, x #идиома

array = [1, 2, 3]
a = array[0]
1
b = array[1]
2
a, b, c = array #идиома - множественное присваивание
||= # оператор или присвоить, если в значении переменной нет
#запись дефолтного значения
class Foo
  def bar(key)
    h = {a: 1, b: 2}
    value = hash(key)
    value ||= 0 #value = 0 unless value
    # ... используем value
    #
  end

  def long_method
    sleep(3)
  end

  def memoization
    @m ||= long_method # мемоизация memory find
  end
 end
  foo = Foo.new
  foo.bar(:a)
  1
  foo.bar(:c)
  0
  foo.long_method
  3
  foo.memoization
  3

  class User
    attr_accesor :name

    def has_name? # метод? возвращает тру фолс
      !!name # двойное отрицание
      # name.nil? ? false : true - возвращает труфолс
      # name - возвращает имя либо нил
      # !name -
    end

    def has_not_name?
      !has_name?
    end

    def name=(value)
      @name = value.capitalize
    end
  end

name = "qwerty"
"qwerty"
!name
false
name = nil
!name
true
  user = User.new
  user.has_name?
  false
  user.name = 'dmitry'
  'Dmitry'
  user.has_name?
  true


  #синтаксис # записи массивов + с помощью создания блоков
fruits = %w(apple orange grape)
  ['apple', 'orange', 'grape']
  fruits.map { |f| f.upcase }
  ['APPLE', 'ORANGE', 'GRAPE']
  fruits.map(&:upcase) #возвращает новый массив
  ['APPLE', 'ORANGE', 'GRAPE']
  fruits.each(&:upcase) #возвращает оригинальный массив
  ['apple', 'orange', 'grape']

#использование хэша вместо оператора кэйс?
class Color
  COLORS = { red: "#f00",green: "#0f0", blue: "#00f", white: "fff"}
end
  def code(name)
    @code = COLORS[name] || "#000"
     # @code = case name
    #           when :red
    #             "#f00"
    #           when :green
    #             "#0f0"
    #           when :blue
    #             "#00f"
    #           when :white
    #             "fff"
    #           else
    #             "#000"
    #           end
  end

  alias_method :by_name, :code # элиасы методов - синонимы
end
# метод должен быть менее 10 строк
color = Color.new
  color.code(:nothing)
  "#000"

   def m(hash)
   end
m({a: 1, b: 2})
   nil
   m(a: 1, b: 2)
def m(arg1, hash)
end
   nil
   m(3, a: 1, b: 2)

class Train
  attr_accessors :type, :model, :number, :number_of_wagons

  def initialize(number, *args) #массив
#    def initialize(number, type = "Unknown", model = "Unknown", number_of_wagons = 0 )

    @number = number
      @type = args[0] || "Unknown"
      @model = args[1] || "Unknown"
      @number_of_wagons = args[2] || 0
    # @type = type
    # @model = model
    # @number_of_wagons = number_of_wagons
  end

  t = Train.new('123')
  t = Train.new('123', 'cargo')

  def initialize(number, options = {}) #хэш

    @number = number
    @type = options[:type] || "Unknown"
    @model = options[:model] || "Unknown"
    @number_of_wagons = options[:number_of_wagons] || 0
# @type = type
# @model = model
# @number_of_wagons = number_of_wagons
  end

  t = Train.new('123')
  t = Train.new('123', type: 'cargo')
  t = Train.new('123', number_of_wagons: 5, type: 'cargo')

  # в руби все классы являются открытыми

  class String
    def self.random(length)
      rand(36**length).to_s(36)
    end

      def my_method
        self.capitalize
      end

    def <<(value)
      "#{self} #{value}"
    end
  end

  "str".class
  "str".my_method
  "str"
  "str" << "abc"
"str abc"
  String.random(3)
 "ol6"

  #синглтон метод - возможность добавить некоторый метод к одному объекту

  class Foo
  end
  foo = Foo.new
  foo.m

  class << foo
    def m
      puts "Only for one object"
    end
  end

  foo.m
Only for one object








  -------------------------------------------------------------
ВОПРОСЫ!!!!!!!!!!!!!
про неработающий мик: надо гуглить именно эту модель ноутбука


